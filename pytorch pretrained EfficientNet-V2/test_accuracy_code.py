# -*- coding: utf-8 -*-
"""Test Accuracy code

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J70JyarUzr9NXVnTsZ7NnF6LDldhcp5y
"""

# 구글 드라이브 마운트
from google.colab import drive
drive.mount('/content/drive')

import torch

# CUDA가 사용 가능한지 확인
print(torch.cuda.is_available())  # True면 GPU가 사용 가능, False면 사용 불가

# CUDA의 cuDNN 버전 확인
print(torch.backends.cudnn.version())

# PyTorch 버전 확인
print(torch.__version__)

import os
import glob
import time
import random
import numpy as np
from PIL import Image, ImageFile
import cv2

import torch
import torchvision
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F
from torch.utils.data import Dataset, DataLoader, random_split
from torchvision import datasets, models, transforms
from torchvision.models import efficientnet_v2_s, EfficientNet_V2_S_Weights

from sklearn.metrics import f1_score, precision_score, recall_score, classification_report

from google.colab.patches import cv2_imshow

# 손상된 이미지 허용
ImageFile.LOAD_TRUNCATED_IMAGES = True

# 모델 로드 함수
def load_model(model_path, num_classes):
    model = models.efficientnet_v2_s(weights=None)
    model.classifier[1] = torch.nn.Linear(model.classifier[1].in_features, num_classes)

    state_dict = torch.load(model_path, map_location=device)
    model.load_state_dict(state_dict, strict=False)

    model.to(device)
    model.eval()
    return model

# 이미지 정규화 복원 함수
def denormalize_image(image):
    mean = torch.tensor([0.485, 0.456, 0.406]).view(3, 1, 1)
    std = torch.tensor([0.229, 0.224, 0.225]).view(3, 1, 1)
    image = image * std + mean
    return image

# 정확도, Precision, Recall, F1 Score 계산 함수 (클래스별 포함)
def calculate_metrics(test_loader, model, idx_to_cls):
    model.eval()
    all_labels = []
    all_preds = []

    # 클래스별 정확도 및 성능 측정을 위한 초기화
    class_correct = {cls: 0 for cls in idx_to_cls.keys()}
    class_total = {cls: 0 for cls in idx_to_cls.keys()}

    with torch.no_grad():
        for images, labels in test_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = model(images)
            _, predicted = torch.max(outputs, 1)

            all_labels.extend(labels.cpu().numpy())
            all_preds.extend(predicted.cpu().numpy())

            # 클래스별로 정확도 계산
            for label, prediction in zip(labels, predicted):
                class_name = idx_to_cls.get(label.item(), None)
                if class_name is not None:
                    if label == prediction:
                        class_correct[label.item()] += 1
                    class_total[label.item()] += 1

    # 전체 테스트 정확도 계산
    overall_accuracy = 100 * sum(class_correct.values()) / sum(class_total.values())
    print(f'Overall Test Accuracy: {overall_accuracy:.2f}%')

    # 전체 성능 평가를 위한 classification report 사용 예제
    print("Classification Report:")
    print(classification_report(all_labels, all_preds, target_names=list(idx_to_cls.values())))

# FAKE와 REAL의 예측 분포 확인 함수
def evaluate_class_distribution(model, test_loader):
    model.eval()
    fake_count = 0
    real_count = 0

    with torch.no_grad():
        for images, labels in test_loader:
            images = images.to(device)
            outputs = model(images)
            _, preds = torch.max(outputs, 1)
            fake_count += (preds == 0).sum().item()
            real_count += (preds == 1).sum().item()

    print(f"Predicted FAKE: {fake_count}, Predicted REAL: {real_count}")

# 이미지 탐지 시간 측정 및 출력 함수
def predict_random_images(test_dataset, model, idx_to_cls):
    random_indices = random.sample(range(len(test_dataset)), 10)
    model.eval()

    for idx in random_indices:
        image, label = test_dataset[idx]
        image = image.unsqueeze(0).to(device)

        start_time = time.time()
        with torch.no_grad():
            output = model(image)
            probabilities = torch.nn.functional.softmax(output, dim=1)
            max_prob, predicted = torch.max(probabilities, 1)
        end_time = time.time()
        detection_time = end_time - start_time

        predicted_label = idx_to_cls[predicted.item()]
        true_label = idx_to_cls[label]
        print(f"Predicted: {predicted_label}, True: {true_label}, Confidence: {max_prob.item():.2f}, "
              f"Detection Time: {detection_time:.4f} seconds")

        image = denormalize_image(image.squeeze(0).cpu())
        image_np = image.permute(1, 2, 0).numpy()
        image_np = np.clip(image_np, 0, 1)
        image_np = (image_np * 255).astype('uint8')
        image_bgr = cv2.cvtColor(image_np, cv2.COLOR_RGB2BGR)
        cv2_imshow(image_bgr)

# 설정
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

# 테스트 데이터셋 로드
transform_test = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])


test_data_dir = #TEST DATASET 경로
test_dataset = datasets.ImageFolder(root=test_data_dir, transform=transform_test)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

# 클래스 라벨 딕셔너리 생성
idx_to_cls = {v: k for k, v in test_dataset.class_to_idx.items()}

# 모델 로드 및 테스트
model = load_model('#모델 최고 가중치 pth 파일 경로', num_classes=2)

# 테스트 데이터셋의 정확도 계산 (클래스별 Precision, Recall, F1 Score 포함)
calculate_metrics(test_loader, model, idx_to_cls)

# 각 클래스의 예측 분포를 확인
evaluate_class_distribution(model, test_loader)

# 랜덤 이미지 예측 및 탐지 시간 측정
predict_random_images(test_dataset, model, idx_to_cls)